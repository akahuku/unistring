#!/usr/bin/env node
/*
 * grapheme break property generator
 * =================================
 *
 * format:
 *
 *   +0       +1       +2       +3       +4
 *   --------------------------------------------
 *   11111111 00000000 00010000 11111111 11111111
 *   ^^^^^^^^
 *    value   ^^^^^^^^ ^^^
 *            range length^^^^^ ^^^^^^^^ ^^^^^^^^
 *                               codepoint
 *
 *   note: code point order must be sorted.
 */

import fs from 'fs';
import http from 'http';
import minimist from 'minimist';

const args = minimist(process.argv.slice(2));

function loadFiles (fileURLs) {
	if (fileURLs.length == 0) {
		console.log('all files exists.');
		return;
	}
	const loadSpec = fileURLs.shift();
	const url = loadSpec.url;
	let path = loadSpec.path;
	if (path.substr(-1) == '/') {
		path += /[^\/]+$/.exec(url)[0];
	}
	try {
		const stat = fs.statSync(path);
		console.log('found: ' + path);
		loadFiles(fileURLs);
	}
	catch (e) {
		if (e.code != 'ENOENT') {
			console.log('exception: ' + e.message);
			throw err;
		}
		console.log('not found, loading: ' + url);
		http.get(url, res => {
			let content = '';
			res.setEncoding('utf8');
			res.on('data', chunk => {content += chunk});
			res.on('end', res => {
				fs.writeFileSync(path, content, 'utf8');
				console.log('loaded: ' + path);
				loadFiles(fileURLs);
			});
		});
	}
}

function setup (params) {
	fs.readFile(params.srcFileName, 'utf8', (err, data) => {
		if (err) throw err;
		prepare(params, data);
	});
}

function prepare (params, data) {
	data = data.split('\n');
	params.onSourceLoad && (data = params.onSourceLoad(data));

	for (let i = 0, goal = data.length; i < goal; i++) {
		let line = data[i];
		line = line.replace(/#.*/, '');
		line = line.replace(/^\s+|\s+$/g, '');
		if (line == '') continue;

		let re = /^([0-9A-F]+)(?:\.\.([0-9A-F]+))?\s*;\s*(.+)/.exec(line);
		if (!re) continue;

		if (!re[2]) {
			re[2] = re[1];
		}
		if (!(re[3] in params.propIndex)) {
			params.propIndex[re[3]] = Object.keys(params.propIndex).length;
		}

		params.propData.push([
			parseInt(re[1], 16),
			parseInt(re[2], 16),
			params.propIndex[re[3]]
		]);
	}

	params.onDataCreate && (params.propData = params.onDataCreate(params.propData));
	params.propData.sort((a, b) => a[0] - b[0]);

	for (let i = 0; i < params.propData.length - 1; i++) {
		if (params.propData[i][1] + 1 == params.propData[i + 1][0]
		&&  params.propData[i][2] == params.propData[i + 1][2]) {
			params.propData[i][1] = params.propData[i + 1][1];
			params.propData.splice(i + 1, 1);
			i--;
		}
	}

	makeJs(params);
}

function makeJs (params) {
	function output (...args) {
		console.log(args.join('\n'));
	}
	function self () {
		return process.argv.map((s, index) => {
			return index < 2 ? /[^\/]+$/.exec(s)[0] : s;
		}).join(' ');
	}

	const propData = params.propData;
	const propIndex = params.propIndex;
	const UNIT_SIZE = 5;

	output(
		'\t// GENERATED CODE START <<<1',
		'\t// This data was generated by the command \'' + self() + '\'.',
		'\tconst ' + params.tableName + ' = \'\\'
	);

	/*
	 * table
	 */

	for (let i = 0; i < propData.length; i++) {
		if (propData[i][1] - propData[i][0] + 1 > 2047) {
			propData.splice(i + 1, 0, [
				propData[i][0] + 2047,
				propData[i][1],
				propData[i][2]
			]);
			propData[i][1] = propData[i][0] + 2047 - 1;
		}
	}
	let tmp = new Buffer(propData.length * UNIT_SIZE);
	let offset = 0;
	for (let i = 0, goal = propData.length; i < goal; i++) {
		if (propData[i][2] > 255) {
			throw new Error(
				'#' + i + ': property value too large: ' +
				propData[i][2]);
		}
		if (propData[i][1] - propData[i][0] + 1 > 2047) {
			throw new Error(
				'#' + i + ': range too large: ' +
				(propData[i][1] - propData[i][0] + 1));
		}
		if (propData[i][0] > 0x10ffff) {
			throw new Error(
				'#' + i + ': code point too large: ' +
				propData[i][0].toString(16));
		}
		tmp.writeUInt8(propData[i][2], offset);
		offset += 1;

		tmp.writeUInt32LE(
			((propData[i][1] - propData[i][0] + 1) * 0x200000)
			+ (propData[i][0]),
			offset);
		offset += 4;
	}

	tmp = tmp.toString('hex').toUpperCase().replace(/.{80}/g, '$&\\\n');
	output(
		tmp + '\'.replace(',
		'\t/[0-9A-F]{2}/g,',
		'\tfunction($0){return String.fromCharCode(parseInt($0, 16))});',
		''
	);

	/*
	 * property name
	 */

	/*
	for (var key in propIndex) {
		output('\tvar ' + params.constPrefix + '_' + key + ' = ' + propIndex[key] + ';');
	}
	output('');
	*/

	/*
	 * length of struct
	 */

	output('\tconst ' + params.structLengthVarName + ' = ' + UNIT_SIZE + ';');

	/*
	 * name convert table
	 */

	output(
		`\tconst ${params.constPrefix} = ` +
		JSON.stringify(propIndex, null, '\t')
			.split('\n')
			.map((a, i) => i ? '\t' + a.replace(/"/g, "'") : a)
			.map((a, i) => params.outputCode ? a.replace(/^(\t+)(')/g, `$1/* ${String.fromCharCode(95 + i)} */$2`) : a)
			.join('\n') + ';'
		);

	output(
		`\tconst ${params.constPrefix}_NAMES = Object.keys(${params.constPrefix});`);

	output(
		'',
		'\t// GENERATED CODE END',
		'\t// >>>'
	);
}

function main () {
	let params = {
		unicodeVersion: '14.0.0',
		propData: []
	};

	if (args.u || args['unicode-version']) {
		params.unicodeVersion = args.u || args['unicode-version'];
	}

	if (args.l || args['load-files']) {
		const files = [
			{
				url: 'http://www.unicode.org/Public/#version#/ucd/auxiliary/GraphemeBreakProperty.txt',
				path: __dirname + '/'
			},
			{
				url: 'http://www.unicode.org/Public/#version#/ucd/auxiliary/WordBreakProperty.txt',
				path: __dirname + '/'
			},
			{
				url: 'http://www.unicode.org/Public/#version#/ucd/auxiliary/SentenceBreakProperty.txt',
				path: __dirname + '/'
			},
			{
				url: 'http://www.unicode.org/Public/#version#/ucd/Scripts.txt',
				path: __dirname + '/'
			},
			{
				url: 'http://www.unicode.org/Public/#version#/ucd/auxiliary/GraphemeBreakTest.txt',
				path: __dirname + '/../test/'
			},
			{
				url: 'http://www.unicode.org/Public/#version#/ucd/auxiliary/WordBreakTest.txt',
				path: __dirname + '/../test/'
			}
		];
		files.forEach(function (spec) {
			spec.url = spec.url.replace('#version#', params.unicodeVersion);
		});
		loadFiles(files);
		return;
	}

	if (args.s || args['scripts']) {
		params.srcFileName = __dirname + '/Scripts.txt';
		params.propIndex = {
			'Unknown': 0
		};
		params.tableName = 'SCRIPTS';
		params.structLengthVarName = 'SCRIPTS_PROP_UNIT_LENGTH';
		params.constPrefix = 'SCRIPT';
	}

	else if (args.g || args['grapheme-break-properties']) {
		params.srcFileName = __dirname + '/GraphemeBreakProperty.txt';
		params.propIndex = {
			'Other': 0,
			'SOT': 1,
			'EOT': 2
		};
		params.tableName = 'GRAPHEME_BREAK_PROPS';
		params.structLengthVarName = 'GRAPHEME_BREAK_PROP_UNIT_LENGTH';
		params.constPrefix = 'GBP';
		params.outputCode = true;
	}

	else if (args.w || args['word-break-properties']) {
		params.srcFileName = __dirname + '/WordBreakProperty.txt';
		params.propIndex = {
			'Other': 0,
			'SOT': 1,
			'EOT': 2
		};
		params.tableName = 'WORD_BREAK_PROPS';
		params.structLengthVarName = 'WORD_BREAK_PROP_UNIT_LENGTH';
		params.constPrefix = 'WBP';
		params.outputCode = true;
		params.onSourceLoad = data => {
			// strip Katakana
			data = data.filter(line => {
				return !/;\s*Katakana\s*#/.test(line);
			});

			// override customized data
			try {
				const dataString = data.join('\n');
				const overrides = fs.readFileSync(__dirname + '/WordBreakOverrides.txt', 'utf8')
					.split('\n')
					.filter(line => {
						let re = /^([0-9A-F]+(\.\.[0-9A-F]+)?)/.exec(line);
						return re ? dataString.indexOf('\n' + re[1]) < 0 : true;
					});

				data.push.apply(data, overrides);
			}
			catch (e) {
				if (e.code != 'ENOENT') throw e;
			}

			return data;
		};
	}

	else if (args.e || args['sentence-break-properties']) {
		params.srcFileName = __dirname + '/SentenceBreakProperty.txt';
		params.propIndex = {
			'Other': 0,
			'SOT': 1,
			'EOT': 2
		};
		params.tableName = 'SENTENCE_BREAK_PROPS';
		params.structLengthVarName = 'SENTENCE_BREAK_PROP_UNIT_LENGTH';
		params.constPrefix = 'SBP';
		params.outputCode = true;
	}

	if (!params.srcFileName || args.h || args['?'] || args.help) {
		console.log([
			'options:',
			'  -u --unicode-version=<version>',
			'  -l --load-files',
			'  -s --scripts',
			'  -g --grapheme-break-properties',
			'  -w --word-break-properties',
			'  -e --sentence-break-properties'
		].join('\n'));
		process.exit(1);
	}

	setup(params);
}

main();

// vim:set ts=4 sw=4 fenc=UTF-8 ff=unix ft=javascript fdm=marker :
